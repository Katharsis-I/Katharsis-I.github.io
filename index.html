<!DOCTYPE html>


<html lang="zn-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一些尝试" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 亦</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="亦" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="https://i.328888.xyz/2023/03/13/vLBQa.jpeg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">亦</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['开琼筵以坐花，飞羽觞而醉月。', '', '而浮生若梦，为欢几何？'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-exam"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/07/02/exam/"
    >exam</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/07/02/exam/" class="article-date">
  <time datetime="2023-07-02T14:51:13.000Z" itemprop="datePublished">2023-07-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>测试，卸建模软件注册表删多了 直接重装系统 </p>
<p>git什么的都要重调</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-sum"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/17/sum/"
    >代码随想录算法训练营总结篇</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/17/sum/" class="article-date">
  <time datetime="2023-05-17T13:09:19.000Z" itemprop="datePublished">2023-05-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>从3月中旬到5月中旬，虽然小可说2个月，但大可说60天，发生了很多事，让我认识到自己在知识上有很多欠缺，还有很多很多东西没有学过，真的会吗，会融会贯通吗，能自己搭建一点什么吗。很遗憾，虽然网上教程繁多，傻瓜式、进阶式、展示类，但是不可能满足实际情况，俗称纸上谈兵，这也是我在刷代码随想录时的情况。</p>
<p>纸上得来终觉浅，绝知此事要躬行。说来更加惭愧，因为毕设，因为毕业季总是各种事情，导致并没开营前那种理想畅想。可以说是跌跌撞撞滑轨地趟过来，开始还是都理解的，但到后来因为没接触过直接接近快开摆的地步，倒不是说思路搞不懂，但是不会实现。只能祈祷自己之后有空，重新审视自己的记录，重刷一遍乃至两遍三遍。不会就是不会，这点还是不能含糊的。</p>
<p>数组一直到栈与队列基本还是可以的，不过也是上段说的，我发现有些必要的真不会……，例如某些类/库，虽然问题不大，但是……  这些算是基本中的基本</p>
<p>二叉树算是很大的一类了，利用二叉树可以做的东西，很多，幸好没有红黑树。从这里开始有些思路就跳出我的思维了，更不用说后面的回溯 贪心 动规……</p>
<p>回溯基于二叉树，而‘贪心 动规也可以说不少方法基于回溯，就是在树上挑挑拣拣，加点代码当做剪刀罢了</p>
<p>贪心，脑筋急转弯？不见得，但是很要求灵活性</p>
<p>动规就不说了……吃的最大的亏就是动规，以及背包，5步法，有时候想不到初始，有时候想不到dp公式，等二刷</p>
<p>单调栈可以说是栈的高阶用法？在经历过动规后都不算什么了……</p>
<p>我想我才刚刚揭开了代码的一点点面纱，哦，各位，看看gpt看看ai绘画<del>看看在ns上竟然能跑的王国之泪</del>，真是不可思议，我这个门外汉真是五体投地，看看嵌入式、分布式什么的，方向众多，我也将找到自己的方向，不过在此之前，我可能，还是要看很多东西吧</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day60"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/12/day60/"
    >代码随想录算法训练营Day60|84</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/12/day60/" class="article-date">
  <time datetime="2023-05-11T16:02:55.000Z" itemprop="datePublished">2023-05-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84.柱状图中最大的矩形"></a>84.柱状图中最大的矩形</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">力扣题目链接</a></p>
<p>本来我以为是增 谁知道是减……</p>
<p>但是这样才能找第一个差，毕竟增会有坑</p>
<p><del>其实个人觉得底×1挺好</del></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int largestRectangleArea(int[] heights) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();</span><br><span class="line">                          // 扩元</span><br><span class="line">        int [] newHeights = new int[heights.length + 2];</span><br><span class="line">        newHeights[0] = 0;</span><br><span class="line">        newHeights[newHeights.length - 1] = 0;</span><br><span class="line">        for (int index = 0; index &lt; heights.length; index++)&#123;</span><br><span class="line">            newHeights[index + 1] = heights[index];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        heights = newHeights;</span><br><span class="line">        st.push(0);</span><br><span class="line">        int result = 0;</span><br><span class="line">                            // 1</span><br><span class="line">        for (int i = 1; i &lt; heights.length; i++) &#123;</span><br><span class="line">            //i | st.top()</span><br><span class="line">            if (heights[i] &gt; heights[st.peek()]) &#123;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125; else if (heights[i] == heights[st.peek()]) &#123;</span><br><span class="line">                st.pop(); </span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (heights[i] &lt; heights[st.peek()]) &#123; </span><br><span class="line">                    int mid = st.peek();</span><br><span class="line">                    st.pop();</span><br><span class="line">                    int left = st.peek();</span><br><span class="line">                    int right = i;</span><br><span class="line">                    int w = right - left - 1;</span><br><span class="line">                    int h = heights[mid];</span><br><span class="line">                    result = Math.max(result, w * h);</span><br><span class="line">                &#125;</span><br><span class="line">                st.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day59"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/12/day59/"
    >代码随想录算法训练营Day59|503 42</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/12/day59/" class="article-date">
  <time datetime="2023-05-11T16:02:49.000Z" itemprop="datePublished">2023-05-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="503-下一个更大元素II"><a href="#503-下一个更大元素II" class="headerlink" title="503 下一个更大元素II"></a>503 下一个更大元素II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-ii/">力扣题目链接</a></p>
<p>可否队列</p>
<p>拼接两个的确没想到……   当然可以分类模拟专门讨论首尾 但是……容易被绕进去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] nextGreaterElements(int[] nums) &#123;</span><br><span class="line">        if(nums == null || nums.length &lt;= 1) &#123;</span><br><span class="line">            return new int[]&#123;-1&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        int size = nums.length;</span><br><span class="line">        int[] result = new int[size];</span><br><span class="line">        Arrays.fill(result,-1);/</span><br><span class="line">        Stack&lt;Integer&gt; st= new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for(int i = 0; i &lt; 2*size; i++) &#123;</span><br><span class="line">            while(!st.empty() &amp;&amp; nums[i % size] &gt; nums[st.peek()]) &#123;</span><br><span class="line">                result[st.peek()] = nums[i % size];//更新result</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            st.push(i % size);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42 接雨水"></a>42 接雨水</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">力扣题目链接</a></p>
<p>单调栈就是递增？</p>
<p>忘了可以用双指针……</p>
<p> 不过动态规划我绝对想不出来</p>
<p>等等，虽然是单调栈，坑的地形也是多种多样的，多加代码</p>
<p>但是请注意双指针面积计算是一块一块算，左高右高差 高度差</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] height)&#123;</span><br><span class="line">        int size = height.length;</span><br><span class="line"></span><br><span class="line">        if (size &lt;= 2)</span><br><span class="line">            return 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int index = 1; index &lt; size; index++)&#123;</span><br><span class="line">            int stackTop = stack.peek();</span><br><span class="line">            if (height[index] &lt; height[stackTop])&#123;</span><br><span class="line">                stack.push(index);    //新</span><br><span class="line">            &#125;else if (height[index] == height[stackTop])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                stack.push(index);      //新 平替</span><br><span class="line">            &#125;else&#123;</span><br><span class="line"></span><br><span class="line">                int heightAtIdx = height[index];</span><br><span class="line"></span><br><span class="line">                while (!stack.isEmpty() &amp;&amp; (heightAtIdx &gt; height[stackTop]))&#123;</span><br><span class="line"></span><br><span class="line">                    int mid = stack.pop();</span><br><span class="line">                    if (!stack.isEmpty())&#123;</span><br><span class="line">                //面积计算</span><br><span class="line">                        int left = stack.peek();</span><br><span class="line">                        int h = Math.min(height[left], height[index]) - height[mid];</span><br><span class="line">                        int w = index - left - 1;</span><br><span class="line">                        int hold = h * w;</span><br><span class="line">                        if (hold &gt; 0) sum += hold;</span><br><span class="line">                        stackTop = stack.peek();</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day58"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/12/day58/"
    >代码随想录算法训练营Day58|单调栈739 496</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/12/day58/" class="article-date">
  <time datetime="2023-05-11T16:02:42.000Z" itemprop="datePublished">2023-05-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a>739. 每日温度</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">力扣题目链接</a></p>
<p>首先明确单调栈 </p>
<p>一维数组 寻找任一元素的右边或者左边第一个比自己大或小的元素位置</p>
<p>空间换时间</p>
<p>用栈记录遍历过的元素</p>
<p>存元素下标 顺序 头到底   求大 递增 求小 递减</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] dailyTemperatures(int[] temperatures) &#123;</span><br><span class="line">        int lens=temperatures.length;</span><br><span class="line">        int []res=new int[lens];</span><br><span class="line">        Deque&lt;Integer&gt; stack=new LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(0);</span><br><span class="line">        for(int i=1;i&lt;lens;i++)&#123;</span><br><span class="line"></span><br><span class="line">            if(temperatures[i]&lt;=temperatures[stack.peek()])&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(!stack.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[stack.peek()])&#123;</span><br><span class="line">                    res[stack.peek()]=i-stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return  res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="496-下一个更大元素-I"><a href="#496-下一个更大元素-I" class="headerlink" title="496.下一个更大元素 I"></a>496.下一个更大元素 I</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-greater-element-i/">力扣题目链接</a></p>
<p>终于碰见一个哈希表，但是没想到是哈希表，重复元素理解错了……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; temp = new Stack&lt;&gt;();</span><br><span class="line">        int[] res = new int[nums1.length];</span><br><span class="line">        Arrays.fill(res,-1);  //-1</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 0 ; i&lt; nums1.length ; i++)&#123;</span><br><span class="line">            hashMap.put(nums1[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        temp.add(0);</span><br><span class="line">        for (int i = 1; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            if (nums2[i] &lt;= nums2[temp.peek()]) &#123;</span><br><span class="line">                temp.add(i);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                while (!temp.isEmpty() &amp;&amp; nums2[temp.peek()] &lt; nums2[i]) &#123;</span><br><span class="line"></span><br><span class="line">                     if (hashMap.containsKey(nums2[temp.peek()]))&#123;     //哈希</span><br><span class="line">                        Integer index = hashMap.get(nums2[temp.peek()]);</span><br><span class="line">                        res[index] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                temp.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day57"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/09/day57/"
    >代码随想录算法训练营Day57|647 516</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/09/day57/" class="article-date">
  <time datetime="2023-05-09T13:18:49.000Z" itemprop="datePublished">2023-05-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647 回文子串"></a>647 回文子串</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindromic-substrings/">力扣题目链接</a></p>
<p>首先想到递归，不过二叉树还是算了吧，但是双指针不太现实，一定麻烦得要死……动规么，中心点怎么办，虽然左右的判断没什么好说的</p>
<p>well，子串还是都能有的，回文……i j ？拆出来函数？</p>
<p>失策，双指针法并不算难，而且动规的重点是中点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSubstrings(String s) &#123;</span><br><span class="line">        int len, ans = 0;</span><br><span class="line">        if (s == null || (len = s.length()) &lt; 1) return 0;</span><br><span class="line">        for (int i = 0; i &lt; 2 * len - 1; i++) &#123;</span><br><span class="line">            int left = i / 2, right = left + i % 2;</span><br><span class="line">            while (left &gt;= 0 &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSubstrings(String s) &#123;</span><br><span class="line">        int len, ans = 0;</span><br><span class="line">        if (s == null || (len = s.length()) &lt; 1) return 0;</span><br><span class="line">        boolean[][] dp = new boolean[len][len];</span><br><span class="line">        for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">            for (int i = 0; i &lt;= j; i++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                   if (j - i &lt; 3) &#123;</span><br><span class="line">                        dp[i][j] = true;  //两种情况</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        dp[i][j] = dp[i + 1][j - 1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; len; j++) &#123;</span><br><span class="line">                if (dp[i][j]) ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="516-最长回文子序列"><a href="#516-最长回文子序列" class="headerlink" title="516 最长回文子序列"></a>516 最长回文子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-subsequence/">力扣题目链接</a></p>
<p>子序列和回文的嵌套  详情看前几天……</p>
<p>没想过是后序 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int longestPalindromeSubseq(String s) &#123;</span><br><span class="line">        int len = s.length();</span><br><span class="line">        int[][] dp = new int[len + 1][len + 1];</span><br><span class="line">        for (int i = len - 1; i &gt;= 0; i--) &#123; </span><br><span class="line">            dp[i][i] = 1;</span><br><span class="line">            for (int j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">                if (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + 1][j - 1] + 2;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + 1][j], Math.max(dp[i][j], dp[i][j - 1]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[0][len - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day56"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/09/day56/"
    >代码随想录算法训练营Day56|583 72</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/09/day56/" class="article-date">
  <time datetime="2023-05-09T13:18:26.000Z" itemprop="datePublished">2023-05-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="583-两个字符串的删除操作"><a href="#583-两个字符串的删除操作" class="headerlink" title="583. 两个字符串的删除操作"></a>583. 两个字符串的删除操作</h1><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-operation-for-two-strings/">力扣题目链接</a></p>
<p>逆转一下，用两个字符串长度减去最长公共子序列，这个思路很巧妙也能书接上文，可惜很难想出来。而正规的动规……  与递归有点相同 ，全部遍历，条件筛取 一点一点堆出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minDistance(String word1, String word2) &#123;</span><br><span class="line">        int[][] dp = new int[word1.length() + 1][word2.length() + 1];</span><br><span class="line">        for (int i = 0; i &lt; word1.length() + 1; i++) dp[i][0] = i;</span><br><span class="line">        for (int j = 0; j &lt; word2.length() + 1; j++) dp[0][j] = j;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; word1.length() + 1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; word2.length() + 1; j++) &#123;</span><br><span class="line">                if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2,</span><br><span class="line">                                        Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72 编辑距离"></a>72 编辑距离</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/">力扣题目链接</a></p>
<p>确实很难，非常难，前面的动规不熟直接导致这一题满头问号……</p>
<p>精髓是这一句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;</span><br></pre></td></tr></table></figure>

<p>矩形，if条件筛选？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int minDistance(String word1, String word2) &#123;</span><br><span class="line">    int m = word1.length();</span><br><span class="line">    int n = word2.length();</span><br><span class="line">    int[][] dp = new int[m + 1][n + 1];</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        dp[i][0] =  i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">        dp[0][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= m; i++) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; j++) &#123;</span><br><span class="line">            if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - 1][j - 1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>确实，前面的题就是为了这道题作铺垫</p>
<p>不过很明显我现在还不算懂这题</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day55"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/09/day55/"
    >代码随想录算法训练营Day55|392 115</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/09/day55/" class="article-date">
  <time datetime="2023-05-09T13:17:00.000Z" itemprop="datePublished">2023-05-09</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392 判断子序列"></a>392 判断子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/is-subsequence/">力扣题目链接</a></p>
<p>双指针   哈希不行，顺序</p>
<p>算是之前的加上条件判断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isSubsequence(String s, String t) &#123;</span><br><span class="line">        int length1 = s.length(); int length2 = t.length();</span><br><span class="line">        int[][] dp = new int[length1+1][length2+1];</span><br><span class="line"></span><br><span class="line">        for(int i = 1; i &lt;= length1; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= length2; j++)&#123;</span><br><span class="line">                if(s.charAt(i-1) == t.charAt(j-1))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-1][j-1] + 1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(dp[length1][length2] == length1)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="115-不同的子序列"><a href="#115-不同的子序列" class="headerlink" title="115 不同的子序列"></a>115 不同的子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distinct-subsequences/">力扣题目链接</a></p>
<p>很难说怎么具体解释……</p>
<p>与上题比较，为什么开始会有一个for循环，当然递推公式是可以理解的</p>
<p>如果能看文章看懂，一般我不太会看视频，视频的效率比较低 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numDistinct(String s, String t) &#123;</span><br><span class="line">        int[][] dp = new int[s.length() + 1][t.length() + 1];</span><br><span class="line">        for (int i = 0; i &lt; s.length() + 1; i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; s.length() + 1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; t.length() + 1; j++) &#123;</span><br><span class="line">                if (s.charAt(i - 1) == t.charAt(j - 1)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day53"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/06/day53/"
    >代码随想录算法训练营Day53|1143 1035 53</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/06/day53/" class="article-date">
  <time datetime="2023-05-05T17:26:17.000Z" itemprop="datePublished">2023-05-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143 最长公共子序列"></a>1143 最长公共子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/">力扣题目链接</a></p>
<p>这次不是连续 </p>
<p>如何合并两个序列显然是二维数组，但是怎么设计？</p>
<p>初始化自然为0但是递推的顺序 递推的公式 需要从源头梳理</p>
<p>这次看代码其实还好理解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int longestCommonSubsequence(String text1, String text2) &#123;</span><br><span class="line">        int[][] dp = new int[text1.length() + 1][text2.length() + 1]; </span><br><span class="line">        </span><br><span class="line">        for (int i = 1 ; i &lt;= text1.length() ; i++) &#123;</span><br><span class="line">            char char1 = text1.charAt(i - 1);</span><br><span class="line"></span><br><span class="line">            for (int j = 1; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">                char char2 = text2.charAt(j - 1);</span><br><span class="line"></span><br><span class="line">                if (char1 == char2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[text1.length()][text2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035 不相交的线"></a>1035 不相交的线</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/uncrossed-lines/">力扣题目链接</a></p>
<p>……没想到还是最长公共，不过的确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">    public int maxUncrossedLines(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int len1 = nums1.length;</span><br><span class="line">        int len2 = nums2.length;</span><br><span class="line">        int[][] dp = new int[len1 + 1][len2 + 1];</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= len1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= len2; j++) &#123;</span><br><span class="line"> </span><br><span class="line">                if (nums1[i - 1] == nums2[j - 1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">力扣题目链接</a></p>
<p>之前用过贪心</p>
<p>动态规划这题是比子序列好一点</p>
<p>但是核心思路还是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int maxSubArray(int[] nums) &#123;</span><br><span class="line">       if (nums.length == 0) </span><br><span class="line">           return 0;</span><br><span class="line"></span><br><span class="line">       int res = nums[0];</span><br><span class="line">       int[] dp = new int[nums.length];</span><br><span class="line">       dp[0] = nums[0];</span><br><span class="line"></span><br><span class="line">       for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">           dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);</span><br><span class="line">           res = res &gt; dp[i] ? res : dp[i];   //刷新</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day52"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/05/05/day52/"
    >代码随想录算法训练营Day52|300 674 718</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/05/05/day52/" class="article-date">
  <time datetime="2023-05-04T17:15:15.000Z" itemprop="datePublished">2023-05-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">力扣题目链接</a></p>
<p>没料到这会是动规 重点应当是状态转移方程</p>
<p>判断严格递增 所以有了if语句</p>
<p>最长是减一位置的最长的序列+1的最大值 </p>
<p>不过说实话，这个思路我不是很能理解，如果可能的话，我倾向于双指针导出新序列</p>
<pre><code>class Solution &#123;
    public int lengthOfLIS(int[] nums) &#123;
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        for (int i = 0; i &lt; dp.length; i++) &#123;
            for (int j = 0; j &lt; i; j++) &#123;
                if (nums[i] &gt; nums[j]) &#123;
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                &#125;
            &#125;
        &#125;
        int res = 0;
        for (int i = 0; i &lt; dp.length; i++) &#123;
            res = Math.max(res, dp[i]);
        &#125;
        return res;
    &#125;
&#125;   
</code></pre>
<h2 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674 最长连续递增序列"></a>674 最长连续递增序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/">力扣题目链接</a></p>
<p>此题为未排序版本且连续，于是突然察觉，上题双指针可能有个问题</p>
<p>接下来的数无疑是递增的 但是排在后面的次高的数或许会更长 躺</p>
<p>前面貌似有贪心类似题</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static int findLengthOfLCIS(int[] nums) &#123;</span><br><span class="line">       int[] dp = new int[nums.length];</span><br><span class="line">       for (int i = 0; i &lt; dp.length; i++) &#123;</span><br><span class="line">           dp[i] = 1;</span><br><span class="line">       &#125;</span><br><span class="line">       int res = 1;</span><br><span class="line">       for (int i = 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">           if (nums[i + 1] &gt; nums[i]) &#123;</span><br><span class="line">               dp[i + 1] = dp[i] + 1;</span><br><span class="line">           &#125;</span><br><span class="line">           res = res &gt; dp[i + 1] ? res : dp[i + 1];</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="718-最长重复子数组"><a href="#718-最长重复子数组" class="headerlink" title="718 最长重复子数组"></a>718 最长重复子数组</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/">力扣题目链接</a></p>
<p>不可置否 我只能说动规我恐怕2刷才行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findLength(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int[][] dp = new int[nums1.length + 1][nums2.length + 1];</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; nums1.length + 1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; nums2.length + 1; j++) &#123;</span><br><span class="line">                if (nums1[i - 1] == nums2[j - 1]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">                    result = Math.max(result, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> safir
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="亦"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Code</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/aboutme">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=535056564&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>