<!DOCTYPE html>


<html lang="zn-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一些尝试" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 亦</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="亦" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="https://i.328888.xyz/2023/03/13/vLBQa.jpeg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">亦</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['开琼筵以坐花，飞羽觞而醉月。', '', '而浮生若梦，为欢几何？'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-day44"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/27/day44/"
    >day44</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/27/day44/" class="article-date">
  <time datetime="2023-04-26T20:28:18.000Z" itemprop="datePublished">2023-04-27</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day43"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/27/day43/"
    >代码随想录算法训练营Day43|1049 494 474</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/27/day43/" class="article-date">
  <time datetime="2023-04-26T20:28:10.000Z" itemprop="datePublished">2023-04-27</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h3 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049 最后一块石头的重量II"></a>1049 最后一块石头的重量II</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-stone-weight-ii/">力扣题目链接</a></p>
<p>想了半天 怎么两两相消，忘了天平直接看相差  熬夜熬得……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int lastStoneWeightII(int[] stones) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int s : stones) &#123;</span><br><span class="line">            sum += s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        int[][] dp = new int[stones.length][target + 1];</span><br><span class="line">        for (int j = stones[0]; j &lt;= target; j++) &#123;</span><br><span class="line">            dp[0][j] = stones[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; stones.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= target; j++) &#123;</span><br><span class="line">                if (j &gt;= stones[i]) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    dp[i][j] = dp[i - 1][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(dp[stones.length - 1][target]);</span><br><span class="line">        return (sum - dp[stones.length - 1][target]) - dp[stones.length - 1][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494 目标和"></a>494 目标和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/">力扣题目链接</a></p>
<p>一开始想到的是24点，但是那比这复杂多了 怎么办呢，遍历回溯属于是……过于那什么的解法 复杂度……</p>
<p>没想到还是两队     <del>果然还是原道</del></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findTargetSumWays(int[] nums, int target) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">             sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        if ( target &lt; 0 &amp;&amp; sum &lt; -target) </span><br><span class="line">             return 0;</span><br><span class="line">        if ((target + sum) % 2 != 0)</span><br><span class="line">              return 0;</span><br><span class="line">        int size = (target + sum) / 2;</span><br><span class="line">        if(size &lt; 0) //没想到</span><br><span class="line">              size = -size;</span><br><span class="line">        int[] dp = new int[size + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            for (int j = size; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474 一和零"></a>474 一和零</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ones-and-zeroes/">力扣题目链接</a></p>
<p>一开始我以为是贪心不错，从左边遇见的第一个1计数，直到n个，驱逐最大，但是重复进入很难办    排序？ 但是不能兼顾两个指标排序  所以 动态规划也是两个维度 啊哈哈哈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int findMaxForm(String[] strs, int m, int n) &#123;</span><br><span class="line">        int[][] dp = new int[m + 1][n + 1];</span><br><span class="line">        int oneNum, zeroNum;</span><br><span class="line">        for (String str : strs) &#123;</span><br><span class="line">            oneNum = 0;</span><br><span class="line">            zeroNum = 0;</span><br><span class="line">            for (char ch : str.toCharArray()) &#123;</span><br><span class="line">                if (ch == &#x27;0&#x27;) &#123;</span><br><span class="line">                    zeroNum++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    oneNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = m; i &gt;= zeroNum; i--) &#123;</span><br><span class="line">                for (int j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line"></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);</span><br><span class="line">      </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day42"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/24/day42/"
    >代码随想录算法训练营Day42|背包问题01 416</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/24/day42/" class="article-date">
  <time datetime="2023-04-23T21:26:33.000Z" itemprop="datePublished">2023-04-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>中途没保存结果从头开始（惨叫    我直接简化了</p>
<h2 id="背包问题01"><a href="#背包问题01" class="headerlink" title="背包问题01"></a>背包问题01</h2><p>有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品只能用一次</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class BagProblem &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] weight = &#123;1,3,4&#125;;</span><br><span class="line">        int[] value = &#123;15,20,30&#125;;</span><br><span class="line">        int bagSize = 4;</span><br><span class="line">        testWeightBagProblem(weight,value,bagSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        int goods = weight.length; </span><br><span class="line">        int[][] dp = new int[goods][bagSize + 1];</span><br><span class="line"></span><br><span class="line">        for (int j = weight[0]; j &lt;= bagSize; j++) &#123;</span><br><span class="line">            dp[0][j] = value[0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; weight.length; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                if (j &lt; weight[i]) &#123;</span><br><span class="line"></span><br><span class="line">                    dp[i][j] = dp[i-1][j];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line"></span><br><span class="line">                    dp[i][j] = Math.max(dp[i-1][j] , dp[i-1][j-weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; goods; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt;= bagSize; j++) &#123;</span><br><span class="line">                System.out.print(dp[i][j] + &quot;\t&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而一维</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>

<p>倒序遍历   先物品，再背包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       int[] weight = &#123;1, 3, 4&#125;;</span><br><span class="line">       int[] value = &#123;15, 20, 30&#125;;</span><br><span class="line">       int bagWight = 4;</span><br><span class="line">       testWeightBagProblem(weight, value, bagWight);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight)&#123;</span><br><span class="line">       int wLen = weight.length;</span><br><span class="line">       int[] dp = new int[bagWeight + 1];</span><br><span class="line">       for (int i = 0; i &lt; wLen; i++)&#123;</span><br><span class="line">           for (int j = bagWeight; j &gt;= weight[i]; j--)&#123;</span><br><span class="line">               dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int j = 0; j &lt;= bagWeight; j++)&#123;</span><br><span class="line">           System.out.print(dp[j] + &quot; &quot;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416 分割等和子集"></a>416 分割等和子集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">力扣题目链接</a></p>
<p>只要sum/2</p>
<p>有一种给数组求满足指定值的感觉 不过一般都是map？集合？双指针？反正不是动态规划</p>
<p>但是需要等于，而不是在容量内</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean canPartition(int[] nums) &#123;</span><br><span class="line">        if(nums == null || nums.length == 0)</span><br><span class="line">            return false;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for(int num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        if(sum % 2 != 0) </span><br><span class="line">            return false;</span><br><span class="line">        int target = sum / 2;</span><br><span class="line">        int[] dp = new int[target + 1];</span><br><span class="line">        for(int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day41"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/23/day41/"
    >代码随想录算法训练营Day41|343 96</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/23/day41/" class="article-date">
  <time datetime="2023-04-22T19:09:20.000Z" itemprop="datePublished">2023-04-23</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>不得不说这两题真的都很难，虽然是搭积木，但是没有图纸</p>
<h2 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343 整数拆分"></a>343 整数拆分</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/integer-break/">力扣题目链接</a></p>
<p>dp[i]  (i-j) * j  dp[i-j] * j</p>
<p>dp[0] dp[1]不该初始化 无意义</p>
<p>直接dp[2]=1</p>
<p>当然是拆分成近似的数相乘最好，说起来不到一个星期前看到过类似的题，直接说拆两个，但是这题可不会指定2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        int[] dp = new int[n+1];</span><br><span class="line">        dp[2] = 1;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++) &#123;</span><br><span class="line">            for(int j = 1; j &lt;= i-j; j++) &#123;</span><br><span class="line"></span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j*(i-j), j*dp[i-j]));</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">                //j * dp[i - j] 拆分i为多个</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96 不同的二叉搜索树"></a>96 不同的二叉搜索树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">力扣题目链接</a></p>
<p>之前的二叉树滑动比喻，差不多</p>
<p>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>大方向 主轴 的滑动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j - 1] * dp[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day39"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/21/day39/"
    >代码随想录算法训练营Day39|62 63</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/21/day39/" class="article-date">
  <time datetime="2023-04-21T08:04:47.000Z" itemprop="datePublished">2023-04-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">力扣题目链接</a></p>
<p>回溯   也叫做深搜？</p>
<p>二叉树叶子节点倒也没错，毕竟回溯到最后的条件限定也不能完全依照二叉树</p>
<p>但是动态呢</p>
<p>爬梯子变成多维？   数学公式虽然能直接推……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static int uniquePaths(int m, int n) &#123;</span><br><span class="line">       int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">           dp[i][0] = 1;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">           dp[0][i] = 1;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">           for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">               dp[i][j] = dp[i-1][j]+dp[i][j-1];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return dp[m-1][n-1];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="63-不同路径"><a href="#63-不同路径" class="headerlink" title="63 不同路径"></a>63 不同路径</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths-ii/">力扣题目链接</a></p>
<p>障碍的判定 break不行，按照上题的逻辑需要立刻置0</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;</span><br><span class="line">        int m = obstacleGrid.length;</span><br><span class="line">        int n = obstacleGrid[0].length;</span><br><span class="line">        int[][] dp = new int[m][n];</span><br><span class="line"></span><br><span class="line">        if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) &#123;</span><br><span class="line">            dp[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) &#123;</span><br><span class="line">            dp[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; m; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = (obstacleGrid[i][j] == 0) ? dp[i - 1][j] + dp[i][j - 1] : 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day38"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/21/day38/"
    >代码随想录算法训练营Day38|动态规划 509 70 746</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/21/day38/" class="article-date">
  <time datetime="2023-04-21T08:04:24.000Z" itemprop="datePublished">2023-04-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="动态规划简要介绍"><a href="#动态规划简要介绍" class="headerlink" title="动态规划简要介绍"></a>动态规划简要介绍</h2><p>简称DP 和上一个状态有关</p>
<p>确定dp数组 下标  递推公式  初始化 遍历顺序</p>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509  斐波那契数"></a>509  斐波那契数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接</a></p>
<pre><code>class Solution &#123;
    public int fib(int n) &#123;
        if (n &lt; 2) return n;             
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int index = 2; index &lt;= n; index++)&#123;
            dp[index] = dp[index - 1] + dp[index - 2];
        &#125;
        return dp[n];
    &#125;
&#125;     
</code></pre>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接</a></p>
<p>递归？直接看有哪些可到n 不过不是动态规划</p>
<pre><code>public int climbStairs(int n) &#123;
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i &lt;= n; i++) &#123;
        dp[i] = dp[i - 1] + dp[i - 2];
    &#125;
    return dp[n];
&#125;
</code></pre>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a>746 使用最小花费爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接</a></p>
<p>本来以为需要贪心，毕竟每一步是有花费的，不过……为什么不直接了当最后统计最小呢 是我想太多了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int len = cost.length;</span><br><span class="line">        int[] dp = new int[len + 1];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - 1] + cost[i - 1],</span><br><span class="line">                             dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day37"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/20/day37/"
    >代码随想录算法训练营Day37|738 968 总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/20/day37/" class="article-date">
  <time datetime="2023-04-20T06:27:54.000Z" itemprop="datePublished">2023-04-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a>738 单调递增的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接</a></p>
<p>区间？两个条件的限制</p>
<pre><code>class Solution &#123;
    public int monotoneIncreasingDigits(int n) &#123;
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();
        int start = s.length();
        for (int i = s.length() - 2; i &gt;= 0; i--) &#123;
            if (chars[i] &gt; chars[i + 1]) &#123;
                chars[i]--;
                start = i+1;
            &#125;
        &#125;
        for (int i = start; i &lt; s.length(); i++) &#123;
            chars[i] = &#39;9&#39;;
        &#125;
        return Integer.parseInt(String.valueOf(chars));
    &#125;
&#125; 
</code></pre>
<h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接</a></p>
<p>真不会，虽然有大致的思路但是真不会，是回溯，但是，如何回溯是不会</p>
<p>如何计数？只能看示例 <del>然后示例也一脸懵</del></p>
<pre><code>class Solution &#123;
    int  res=0;
    public int minCameraCover(TreeNode root) &#123;
        if(minCame(root)==0)&#123;
            res++;
        &#125;
        return res;
    &#125;


    public int minCame(TreeNode root)&#123;
        if(root==null)&#123;
            return 2;
        &#125;
        int left=minCame(root.left);
        int  right=minCame(root.right);

        if(left==2&amp;&amp;right==2)&#123;
            //(2,2)
            return 0;
        &#125;else if(left==0||right==0)&#123;
            res++;
            return 1;
        &#125;else&#123;
            return 2;
        &#125;
    &#125;
&#125;      
</code></pre>
<p>总结，贪心大概只有思路内核相同，其它并无区别 突出一个灵活</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day36"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/20/day36/"
    >代码随想录算法训练营Day36|435 763 56</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/20/day36/" class="article-date">
  <time datetime="2023-04-20T06:27:43.000Z" itemprop="datePublished">2023-04-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">力扣题目链接</a></p>
<p>只用输出数量  如果是输出区间就麻烦了</p>
<pre><code>class Solution &#123;
    public int eraseOverlapIntervals(int[][] intervals) &#123;
        Arrays.sort(intervals, (a,b)-&gt; &#123;
            return Integer.compare(a[0],b[0]);
        &#125;);

        int count = 1;
        for(int i = 1;i &lt; intervals.length;i++)&#123;
            if(intervals[i][0] &lt; intervals[i-1][1])&#123;
                intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]);
                continue;
            &#125;else&#123;
                count++;
            &#125;    
        &#125;
        return intervals.length - count;
    &#125;
&#125;
  
</code></pre>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">力扣题目链接</a></p>
<p>一开始没有理解，“每个字母最多出现在一个片段中”</p>
<p>也就是说不能和其他片段重叠，还是区间问题</p>
<p>一开始联想到的是哈希，但是那适用于验证问题而不是分割 单纯分割的话……不行 跪了</p>
<pre><code>class Solution &#123;
    public List&lt;Integer&gt; partitionLabels(String S) &#123;
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        int[] edge = new int[26];
        char[] chars = S.toCharArray();

        for (int i = 0; i &lt; chars.length; i++) &#123;
            edge[chars[i] - &#39;a&#39;] = i;
        &#125;        //刷新边缘

        int idx = 0;
        int last = -1;
        for (int i = 0; i &lt; chars.length; i++) &#123;
            idx = Math.max(idx,edge[chars[i] - &#39;a&#39;]);
            if (i == idx) &#123;
                list.add(i - last);
                last = i;
            &#125;
        &#125;
        return list;
    &#125;
&#125;

   
</code></pre>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">力扣题目链接</a></p>
<p>没什么好说的，区间检测</p>
<pre><code>class Solution &#123;
    public int[][] merge(int[][] intervals) &#123;
        List&lt;int[]&gt; res = new LinkedList&lt;&gt;();
        Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));
        int start = intervals[0][0];
        int end = intervals[0][1];

        for (int i = 1; i &lt; intervals.length; i++) &#123;
            if (intervals[i][0] &gt; end) &#123;
                res.add(new int[]&#123;start, end&#125;);
                start = intervals[i][0];
                end = intervals[i][1];
            &#125; else &#123;           //合并
                end = Math.max(end, intervals[i][1]);
            &#125;
        &#125;

        res.add(new int[]&#123;start, end&#125;);
        return res.toArray(new int[res.size()][]);
    &#125;
&#125;
&#125;
  
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day35"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/18/day35/"
    >代码随想录算法训练营Day35|860 406 452</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/18/day35/" class="article-date">
  <time datetime="2023-04-18T09:25:07.000Z" itemprop="datePublished">2023-04-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">力扣题目链接</a></p>
<p>挺简单的，小时候或多或少都会拿钱出去买东西，也有各种脑筋急转弯等等等等</p>
<p><del>而现在移动支付已经一扫天下，但是老人呢</del></p>
<pre><code>class Solution &#123;
    public boolean lemonadeChange(int[] bills) &#123;
        int five = 0;
        int ten = 0;

        for (int i = 0; i &lt; bills.length; i++) &#123;
            if (bills[i] == 5) &#123;
                five++;
            &#125; 
            if (bills[i] == 10) &#123;
                five--;
                ten++;
            &#125; else if (bills[i] == 20) &#123;
                if (ten &gt; 0) &#123;
                    ten--;
                    five--;
                &#125; else &#123;
                    five -= 3;
                &#125;
            &#125;
            if (five &lt; 0 || ten &lt; 0)
                return false;
        &#125;

        return true;
    &#125;
&#125;    
</code></pre>
<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">力扣题目链接</a></p>
<p>简而言之就是看后面那个元素排序</p>
<p>又或者说，还是两个不等式</p>
<p>先身高，然后看跳过几个插入</p>
<p>随想录所提供的代码不理解</p>
<pre><code>class Solution &#123;
    public int[][] reconstructQueue(int[][] people) &#123;
        Arrays.sort(people, (a, b) -&gt; &#123;
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        &#125;);

        LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;();

        for (int[] p : people) &#123;
            que.add(p[1],p);
        &#125;

        return que.toArray(new int[people.length][]);
    &#125;
&#125;   
</code></pre>
<h2 id="452-用最少数量的箭引爆地球"><a href="#452-用最少数量的箭引爆地球" class="headerlink" title="452 用最少数量的箭引爆地球"></a>452 用最少数量的箭引爆地球</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接</a></p>
<p>直接看重叠区间</p>
<p>代码的确不知道怎么写，但是take it</p>
<pre><code>class Solution &#123;
    public int findMinArrowShots(int[][] points)
        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));

        int count = 1;  
        for (int i = 1; i &lt; points.length; i++) &#123;
            if (points[i][0] &gt; points[i - 1][1]) &#123; 
                count++; // 没重
            &#125; else &#123;       //重了
                points[i][1] = Math.min(points[i][1], points[i - 1][1]); 
            &#125;
        &#125;
        return count;
    &#125;
&#125;   
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day34"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/17/day34/"
    >代码随想录算法训练营Day34|1005 134 135</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/17/day34/" class="article-date">
  <time datetime="2023-04-16T19:34:54.000Z" itemprop="datePublished">2023-04-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005 K次取反后最大化的数组和"></a>1005 K次取反后最大化的数组和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接</a></p>
<p>只能说，就算是最浪费复杂度的代码也比不动要好，要排序就是要排序</p>
<p>不会写，真是抱歉了</p>
<pre><code>class Solution &#123;
    public int largestSumAfterKNegations(int[] A, int K) &#123;
        if (A.length == 1)
           return k % 2 == 0 ? A[0] : -A[0];
        Arrays.sort(A);
        int sum = 0;
        int idx = 0;
        for (int i = 0; i &lt; K; i++) &#123;
            if (i &lt; A.length - 1 &amp;&amp; A[idx] &lt; 0) &#123;
                A[idx] = -A[idx];
                if (A[idx] &gt;= Math.abs(A[idx + 1]))
                  idx++;
                  continue;
            &#125;
            A[idx] = -A[idx];
        &#125;

        for (int i = 0; i &lt; A.length; i++) &#123;
            sum += A[i];
        &#125;
        return sum;
    &#125;
&#125; 
</code></pre>
<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">力扣题目链接</a></p>
<p>油一直大于消耗量就ok了，但是这算是贪心吗</p>
<p>贪心和正常脑回路并没有相差多少</p>
<pre><code>class Solution &#123;
public:
    int canCompleteCircuit(int[] gas, int[] cost) &#123;
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i &lt; gas.size(); i++) &#123;
            curSum += gas[i] - cost[i];

            totalSum += gas[i] - cost[i];

            if (curSum &lt; 0) &#123;   
                start = i + 1;  
                curSum = 0;     
            &#125;
        &#125;
        if (totalSum &lt; 0) 
            return -1; 

        return start;
    &#125;
&#125;;  
</code></pre>
<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a>135 分发糖果</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">力扣题目链接</a></p>
<p>可以理解为一组不等式</p>
<pre><code>class Solution &#123;
    public int candy(int[] ratings) &#123;
        int len = ratings.length;
        int[] candyVec = new int[len];
        int ans = 0;
        candyVec[0] = 1;

        for (int i = 1; i &lt; len; i++) &#123;
            candyVec[i] = (ratings[i] &gt; ratings[i - 1]) ? candyVec[i - 1] + 1 : 1;
        &#125;

        for (int i = len - 2; i &gt;= 0; i--) &#123;   //这里是-2……
            if (ratings[i] &gt; ratings[i + 1]) &#123;

                candyVec[i] = Math.max(candyVec[i], candyVec[i + 1] + 1);

            &#125;
        &#125;

        for (int num : candyVec) &#123;
            ans += num;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> safir
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="亦"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Code</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/aboutme">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=535056564&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>