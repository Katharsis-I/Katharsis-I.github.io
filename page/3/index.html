<!DOCTYPE html>


<html lang="zn-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="一些尝试" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 亦</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    <link rel="alternate" href="/atom.xml" title="亦" type="application/atom+xml">
</head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="https://i.328888.xyz/2023/03/13/vLBQa.jpeg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">亦</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['开琼筵以坐花，飞羽觞而醉月。', '', '而浮生若梦，为欢几何？'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-day38"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/21/day38/"
    >代码随想录算法训练营Day38|动态规划 509 70 746</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/21/day38/" class="article-date">
  <time datetime="2023-04-21T08:04:24.000Z" itemprop="datePublished">2023-04-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="动态规划简要介绍"><a href="#动态规划简要介绍" class="headerlink" title="动态规划简要介绍"></a>动态规划简要介绍</h2><p>简称DP 和上一个状态有关</p>
<p>确定dp数组 下标  递推公式  初始化 遍历顺序</p>
<h2 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509  斐波那契数"></a>509  斐波那契数</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/fibonacci-number/">力扣题目链接</a></p>
<pre><code>class Solution &#123;
    public int fib(int n) &#123;
        if (n &lt; 2) return n;             
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int index = 2; index &lt;= n; index++)&#123;
            dp[index] = dp[index - 1] + dp[index - 2];
        &#125;
        return dp[n];
    &#125;
&#125;     
</code></pre>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">力扣题目链接</a></p>
<p>递归？直接看有哪些可到n 不过不是动态规划</p>
<pre><code>public int climbStairs(int n) &#123;
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i &lt;= n; i++) &#123;
        dp[i] = dp[i - 1] + dp[i - 2];
    &#125;
    return dp[n];
&#125;
</code></pre>
<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a>746 使用最小花费爬楼梯</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-cost-climbing-stairs/">力扣题目链接</a></p>
<p>本来以为需要贪心，毕竟每一步是有花费的，不过……为什么不直接了当最后统计最小呢 是我想太多了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">        int len = cost.length;</span><br><span class="line">        int[] dp = new int[len + 1];</span><br><span class="line">        dp[0] = 0;</span><br><span class="line">        dp[1] = 0;</span><br><span class="line">        for (int i = 2; i &lt;= len; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - 1] + cost[i - 1],</span><br><span class="line">                             dp[i - 2] + cost[i - 2]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day37"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/20/day37/"
    >代码随想录算法训练营Day37|738 968 总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/20/day37/" class="article-date">
  <time datetime="2023-04-20T06:27:54.000Z" itemprop="datePublished">2023-04-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="738-单调递增的数字"><a href="#738-单调递增的数字" class="headerlink" title="738 单调递增的数字"></a>738 单调递增的数字</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/monotone-increasing-digits/">力扣题目链接</a></p>
<p>区间？两个条件的限制</p>
<pre><code>class Solution &#123;
    public int monotoneIncreasingDigits(int n) &#123;
        String s = String.valueOf(n);
        char[] chars = s.toCharArray();
        int start = s.length();
        for (int i = s.length() - 2; i &gt;= 0; i--) &#123;
            if (chars[i] &gt; chars[i + 1]) &#123;
                chars[i]--;
                start = i+1;
            &#125;
        &#125;
        for (int i = start; i &lt; s.length(); i++) &#123;
            chars[i] = &#39;9&#39;;
        &#125;
        return Integer.parseInt(String.valueOf(chars));
    &#125;
&#125; 
</code></pre>
<h2 id="968-监控二叉树"><a href="#968-监控二叉树" class="headerlink" title="968 监控二叉树"></a>968 监控二叉树</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-cameras/">力扣题目链接</a></p>
<p>真不会，虽然有大致的思路但是真不会，是回溯，但是，如何回溯是不会</p>
<p>如何计数？只能看示例 <del>然后示例也一脸懵</del></p>
<pre><code>class Solution &#123;
    int  res=0;
    public int minCameraCover(TreeNode root) &#123;
        if(minCame(root)==0)&#123;
            res++;
        &#125;
        return res;
    &#125;


    public int minCame(TreeNode root)&#123;
        if(root==null)&#123;
            return 2;
        &#125;
        int left=minCame(root.left);
        int  right=minCame(root.right);

        if(left==2&amp;&amp;right==2)&#123;
            //(2,2)
            return 0;
        &#125;else if(left==0||right==0)&#123;
            res++;
            return 1;
        &#125;else&#123;
            return 2;
        &#125;
    &#125;
&#125;      
</code></pre>
<p>总结，贪心大概只有思路内核相同，其它并无区别 突出一个灵活</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day36"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/20/day36/"
    >代码随想录算法训练营Day36|435 763 56</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/20/day36/" class="article-date">
  <time datetime="2023-04-20T06:27:43.000Z" itemprop="datePublished">2023-04-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="435-无重叠区间"><a href="#435-无重叠区间" class="headerlink" title="435 无重叠区间"></a>435 无重叠区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-overlapping-intervals/">力扣题目链接</a></p>
<p>只用输出数量  如果是输出区间就麻烦了</p>
<pre><code>class Solution &#123;
    public int eraseOverlapIntervals(int[][] intervals) &#123;
        Arrays.sort(intervals, (a,b)-&gt; &#123;
            return Integer.compare(a[0],b[0]);
        &#125;);

        int count = 1;
        for(int i = 1;i &lt; intervals.length;i++)&#123;
            if(intervals[i][0] &lt; intervals[i-1][1])&#123;
                intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]);
                continue;
            &#125;else&#123;
                count++;
            &#125;    
        &#125;
        return intervals.length - count;
    &#125;
&#125;
  
</code></pre>
<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763 划分字母区间"></a>763 划分字母区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">力扣题目链接</a></p>
<p>一开始没有理解，“每个字母最多出现在一个片段中”</p>
<p>也就是说不能和其他片段重叠，还是区间问题</p>
<p>一开始联想到的是哈希，但是那适用于验证问题而不是分割 单纯分割的话……不行 跪了</p>
<pre><code>class Solution &#123;
    public List&lt;Integer&gt; partitionLabels(String S) &#123;
        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();
        int[] edge = new int[26];
        char[] chars = S.toCharArray();

        for (int i = 0; i &lt; chars.length; i++) &#123;
            edge[chars[i] - &#39;a&#39;] = i;
        &#125;        //刷新边缘

        int idx = 0;
        int last = -1;
        for (int i = 0; i &lt; chars.length; i++) &#123;
            idx = Math.max(idx,edge[chars[i] - &#39;a&#39;]);
            if (i == idx) &#123;
                list.add(i - last);
                last = i;
            &#125;
        &#125;
        return list;
    &#125;
&#125;

   
</code></pre>
<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">力扣题目链接</a></p>
<p>没什么好说的，区间检测</p>
<pre><code>class Solution &#123;
    public int[][] merge(int[][] intervals) &#123;
        List&lt;int[]&gt; res = new LinkedList&lt;&gt;();
        Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));
        int start = intervals[0][0];
        int end = intervals[0][1];

        for (int i = 1; i &lt; intervals.length; i++) &#123;
            if (intervals[i][0] &gt; end) &#123;
                res.add(new int[]&#123;start, end&#125;);
                start = intervals[i][0];
                end = intervals[i][1];
            &#125; else &#123;           //合并
                end = Math.max(end, intervals[i][1]);
            &#125;
        &#125;

        res.add(new int[]&#123;start, end&#125;);
        return res.toArray(new int[res.size()][]);
    &#125;
&#125;
&#125;
  
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day35"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/18/day35/"
    >代码随想录算法训练营Day35|860 406 452</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/18/day35/" class="article-date">
  <time datetime="2023-04-18T09:25:07.000Z" itemprop="datePublished">2023-04-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860 柠檬水找零"></a>860 柠檬水找零</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lemonade-change/">力扣题目链接</a></p>
<p>挺简单的，小时候或多或少都会拿钱出去买东西，也有各种脑筋急转弯等等等等</p>
<p><del>而现在移动支付已经一扫天下，但是老人呢</del></p>
<pre><code>class Solution &#123;
    public boolean lemonadeChange(int[] bills) &#123;
        int five = 0;
        int ten = 0;

        for (int i = 0; i &lt; bills.length; i++) &#123;
            if (bills[i] == 5) &#123;
                five++;
            &#125; 
            if (bills[i] == 10) &#123;
                five--;
                ten++;
            &#125; else if (bills[i] == 20) &#123;
                if (ten &gt; 0) &#123;
                    ten--;
                    five--;
                &#125; else &#123;
                    five -= 3;
                &#125;
            &#125;
            if (five &lt; 0 || ten &lt; 0)
                return false;
        &#125;

        return true;
    &#125;
&#125;    
</code></pre>
<h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queue-reconstruction-by-height/">力扣题目链接</a></p>
<p>简而言之就是看后面那个元素排序</p>
<p>又或者说，还是两个不等式</p>
<p>先身高，然后看跳过几个插入</p>
<p>随想录所提供的代码不理解</p>
<pre><code>class Solution &#123;
    public int[][] reconstructQueue(int[][] people) &#123;
        Arrays.sort(people, (a, b) -&gt; &#123;
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        &#125;);

        LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;();

        for (int[] p : people) &#123;
            que.add(p[1],p);
        &#125;

        return que.toArray(new int[people.length][]);
    &#125;
&#125;   
</code></pre>
<h2 id="452-用最少数量的箭引爆地球"><a href="#452-用最少数量的箭引爆地球" class="headerlink" title="452 用最少数量的箭引爆地球"></a>452 用最少数量的箭引爆地球</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/">力扣题目链接</a></p>
<p>直接看重叠区间</p>
<p>代码的确不知道怎么写，但是take it</p>
<pre><code>class Solution &#123;
    public int findMinArrowShots(int[][] points)
        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));

        int count = 1;  
        for (int i = 1; i &lt; points.length; i++) &#123;
            if (points[i][0] &gt; points[i - 1][1]) &#123; 
                count++; // 没重
            &#125; else &#123;       //重了
                points[i][1] = Math.min(points[i][1], points[i - 1][1]); 
            &#125;
        &#125;
        return count;
    &#125;
&#125;   
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day34"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/17/day34/"
    >代码随想录算法训练营Day34|1005 134 135</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/17/day34/" class="article-date">
  <time datetime="2023-04-16T19:34:54.000Z" itemprop="datePublished">2023-04-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="1005-K次取反后最大化的数组和"><a href="#1005-K次取反后最大化的数组和" class="headerlink" title="1005 K次取反后最大化的数组和"></a>1005 K次取反后最大化的数组和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/">力扣题目链接</a></p>
<p>只能说，就算是最浪费复杂度的代码也比不动要好，要排序就是要排序</p>
<p>不会写，真是抱歉了</p>
<pre><code>class Solution &#123;
    public int largestSumAfterKNegations(int[] A, int K) &#123;
        if (A.length == 1)
           return k % 2 == 0 ? A[0] : -A[0];
        Arrays.sort(A);
        int sum = 0;
        int idx = 0;
        for (int i = 0; i &lt; K; i++) &#123;
            if (i &lt; A.length - 1 &amp;&amp; A[idx] &lt; 0) &#123;
                A[idx] = -A[idx];
                if (A[idx] &gt;= Math.abs(A[idx + 1]))
                  idx++;
                  continue;
            &#125;
            A[idx] = -A[idx];
        &#125;

        for (int i = 0; i &lt; A.length; i++) &#123;
            sum += A[i];
        &#125;
        return sum;
    &#125;
&#125; 
</code></pre>
<h2 id="134-加油站"><a href="#134-加油站" class="headerlink" title="134 加油站"></a>134 加油站</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gas-station/">力扣题目链接</a></p>
<p>油一直大于消耗量就ok了，但是这算是贪心吗</p>
<p>贪心和正常脑回路并没有相差多少</p>
<pre><code>class Solution &#123;
public:
    int canCompleteCircuit(int[] gas, int[] cost) &#123;
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i &lt; gas.size(); i++) &#123;
            curSum += gas[i] - cost[i];

            totalSum += gas[i] - cost[i];

            if (curSum &lt; 0) &#123;   
                start = i + 1;  
                curSum = 0;     
            &#125;
        &#125;
        if (totalSum &lt; 0) 
            return -1; 

        return start;
    &#125;
&#125;;  
</code></pre>
<h2 id="135-分发糖果"><a href="#135-分发糖果" class="headerlink" title="135 分发糖果"></a>135 分发糖果</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/candy/">力扣题目链接</a></p>
<p>可以理解为一组不等式</p>
<pre><code>class Solution &#123;
    public int candy(int[] ratings) &#123;
        int len = ratings.length;
        int[] candyVec = new int[len];
        int ans = 0;
        candyVec[0] = 1;

        for (int i = 1; i &lt; len; i++) &#123;
            candyVec[i] = (ratings[i] &gt; ratings[i - 1]) ? candyVec[i - 1] + 1 : 1;
        &#125;

        for (int i = len - 2; i &gt;= 0; i--) &#123;   //这里是-2……
            if (ratings[i] &gt; ratings[i + 1]) &#123;

                candyVec[i] = Math.max(candyVec[i], candyVec[i + 1] + 1);

            &#125;
        &#125;

        for (int num : candyVec) &#123;
            ans += num;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day32"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/16/day32/"
    >代码随想录算法训练营Day32|122 55 45</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/16/day32/" class="article-date">
  <time datetime="2023-04-15T19:34:47.000Z" itemprop="datePublished">2023-04-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="122-买卖股票的最佳实际II"><a href="#122-买卖股票的最佳实际II" class="headerlink" title="122 买卖股票的最佳实际II"></a>122 买卖股票的最佳实际II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">力扣题目链接</a></p>
<p>有点类似于脑筋急转弯，不过还好  我主要卡在了“万一不知道下一天的价格怎么办”（那就真成命运的选择了）</p>
<pre><code>class Solution &#123;
    public int maxProfit(int[] price) &#123;
        int result = 0;
        for (int i = 1; i &lt; price.length; i++) &#123;
            result += Math.max(prices[i] - prices[i - 1], 0);
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">力扣题目链接</a></p>
<p>这个还是很简单的，很想举出一个反例，不过貌似没有什么逻辑可以推出来……</p>
<pre><code> class Solution &#123;
    public boolean canJump(int[] nums) &#123;
        
        if (nums.length == 1) &#123;
            return true;
        &#125;
        
        int boundary = 0;
        for (int i = 0; i &lt;= boundary; i++) &#123;
            boundary = Math.max(boundary, i + nums[i]);
                 //如果没有math函数的话我大概会用if else，不过显然
            if (boundary &gt;= nums.length - 1) &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h2 id="45-跳跃游戏II"><a href="#45-跳跃游戏II" class="headerlink" title="45 跳跃游戏II"></a>45 跳跃游戏II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">力扣题目链接</a></p>
<p>表示最直接的方法的特殊情况不太好想，但是迂回一点的方法又有点不太理解……well</p>
<p>想想一下搭扣？</p>
<pre><code>class Solution &#123;
public:
    int jump(vector&lt;int&gt;&amp; nums) &#123;
        int curDistance = 0;    // 最终
        int ans = 0;            
        int nextDistance = 0;   //实时更新
        for (int i = 0; i &lt; nums.size() - 1; i++) &#123; 
            nextDistance = max(nums[i] + i, nextDistance); 
            if (i == curDistance) &#123;                 
                curDistance = nextDistance;         
                ans++;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;;
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day31"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/14/day31/"
    >代码随想录算法训练营Day31|贪心455 376 53</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/14/day31/" class="article-date">
  <time datetime="2023-04-14T01:57:30.000Z" itemprop="datePublished">2023-04-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>贪心的套路就是没有套路，随心所欲，常识性推导加举反例</p>
<p>局部最优到全局最优</p>
<h2 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455 分发饼干"></a>455 分发饼干</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/assign-cookies/">力扣题目链接</a></p>
<p>贪心啊，要的是思路 </p>
<p>后序，总是略微有点反直觉（当然你排序换一下就没事了……</p>
<pre><code>class Solution &#123;
    public int findContentChildren(int[] g, int[] s) &#123;
        Arrays.sort(g);
        Arrays.sort(s);
        int chi = 0;
        int count = 0;
        for (int i = 0; i &lt; s.length &amp;&amp; chi &lt; g.length; i++) &#123;
            if (s[i] &gt;= g[chi]) &#123;
                chi++;
                count++;
            &#125;
        &#125;
        return count;
    &#125; 
</code></pre>
<h2 id="376-摆动序列"><a href="#376-摆动序列" class="headerlink" title="376 摆动序列"></a>376 摆动序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/wiggle-subsequence/">力扣题目链接</a></p>
<p>平坡 单调中平坡 数组两端</p>
<pre><code>class Solution &#123;
    public int wiggleMaxLength(int[] nums) &#123;

        if (nums.length &lt;= 1) &#123;
            return nums.length;
        &#125;

        int cur = 0;
        int pre = 0;
        int count = 1;
        for (int i = 1; i &lt; nums.length; i++) &#123;
            curDiff = nums[i] - nums[i - 1];
            if ((cur &gt; 0 &amp;&amp; pre &lt;= 0) || (cur &lt; 0 &amp;&amp; pre &gt;= 0)) &#123;
                count++;
                pre = cur;
            &#125;
        &#125;
        return count;
    &#125;
&#125;  
</code></pre>
<h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53 最大子序和"></a>53 最大子序和</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">力扣题目链接</a></p>
<p>误区一是的，脑测最终结果是sum初始</p>
<p>（为什么脑测误区解释还是脑测……电脑做毕设c盘东西重定义路径了，vscode直接gcc查不到，啊啊啊啊）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        if (nums.length == 1)&#123;</span><br><span class="line">            return nums[0];</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = Integer.MIN_VALUE;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            sum = Math.max(sum, count); ）</span><br><span class="line">            if (count &lt;= 0)&#123;</span><br><span class="line">                count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day30"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/12/day30/"
    >代码随想录算法训练营Day30|332 51 37 *</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/12/day30/" class="article-date">
  <time datetime="2023-04-12T14:59:37.000Z" itemprop="datePublished">2023-04-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="回溯总结"><a href="#回溯总结" class="headerlink" title="回溯总结"></a>回溯总结</h2><p>还是直接看网页比较好</p>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E6%80%BB%E7%BB%93.html#%E8%A7%A3%E6%95%B0%E7%8B%AC%E9%97%AE%E9%A2%98">代码随想录</a></p>
<h2 id="332-重新安排行程"><a href="#332-重新安排行程" class="headerlink" title="332 重新安排行程"></a>332 重新安排行程</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reconstruct-itinerary/">力扣题目链接</a></p>
<p>刚开始甚至没有看懂题……简单的来说就就是把零碎的线段连成一道线</p>
<p>如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合 </p>
<p>的确很容易让人想起来深度搜索，路径方面我又想到了迷宫寻找路径，不过显然深度搜索和这题并不是一个思路  </p>
<p>竟然还是回溯？不过想必剪枝更加麻烦，而且还有闭环</p>
<h2 id="51-N皇后"><a href="#51-N皇后" class="headerlink" title="51 N皇后"></a>51 N皇后</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">力扣题目链接</a></p>
<p>判断斜线只需要一个简单的的2参数for循环，是我想像的过于困难了</p>
<p>但是这并不代表代码就好写了，二维数组的定义</p>
<h2 id="37-解数独"><a href="#37-解数独" class="headerlink" title="37 解数独"></a>37 解数独</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sudoku-solver/">力扣题目链接</a></p>
<p>n皇后进阶 我单方面宣布投降（</p>
<p>看了代码其实还好，注意嵌套的规则</p>
<p>不要以为实现一个步骤多么麻烦也不要以为多么简单，再怎么复杂的代码也是由for while if等语句堆出来的</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day29"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/11/day29/"
    >代码随想录算法训练营Day29|491 46 47</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/11/day29/" class="article-date">
  <time datetime="2023-04-11T09:25:43.000Z" itemprop="datePublished">2023-04-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="491-递增子序列"><a href="#491-递增子序列" class="headerlink" title="491 递增子序列"></a>491 递增子序列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/non-decreasing-subsequences/">力扣题目链接</a></p>
<p>全回溯然后剪枝，条件是长度大于2且保持递增，if不递增，跳出，另一枝回溯</p>
<p>但是注意不能重复  注意continue</p>
<p>赞同回溯，而不是深度优先搜索，虽然底层相同不过没必要</p>
<pre><code>class Solution &#123;
    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();
    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;
        backtracking(nums,0);
        return res;
    &#125;

    private void backtracking (int[] nums, int start) &#123;
        if (path.size() &gt; 1) &#123;
            res.add(new ArrayList&lt;&gt;(path));
        &#125;

        int[] used = new int[201];
        for (int i = start; i &lt; nums.length; i++)&#123;
                       //路径不为空 且 递增（因为路径截取位置的不定性所以一个是path.size一个是num数组
                                //确定已经uesd
            if (!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - 1) ||
                    (used[nums[i] + 100] == 1)) 
               continue;

            used[nums[i] + 100] = 1;
            path.add(nums[i]);
            backtracking(nums, i + 1);
            path.remove(path.size() - 1);

        &#125;
    &#125;
&#125;     
</code></pre>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">力扣题目链接</a></p>
<p>for看起来很美好，问题是n大起来就并不美好了</p>
<p>因为是全排列。本身也不重复，所以（层次）从0开始，but不能重复，path还是要有，也正是因为（层次）从0遍历的原因，path要输入的就是遍历过的全部了</p>
<pre><code>class Solution &#123;
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();
    boolean[] used;
    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;
        if (nums.length == 0)&#123;
            return result;
        &#125;
        used = new boolean[nums.length];

        permuteHelper(nums);

        return result;

    &#125;

    private void permuteHelper(int[] nums)&#123;
        if (path.size() == nums.length)&#123;
            result.add(new ArrayList&lt;&gt;(path));
            return;
        &#125;
        for (int i = 0; i &lt; nums.length; i++)&#123;

            if (used[i])&#123;
                continue;
            &#125;

            used[i] = true;
            path.add(nums[i]);

            permuteHelper(nums);

            path.removeLast();
            used[i] = false;
        &#125;
    &#125;
&#125;   
</code></pre>
<h2 id="47-全排列II"><a href="#47-全排列II" class="headerlink" title="47 全排列II"></a>47 全排列II</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations-ii/">力扣题目链接</a></p>
<p>可包含重复数字，返回不重复 排列</p>
<p>还是要排序，和之前的某题一样，很多题的内核都是相同的，我现在由衷地相信二刷乃至三刷我所用的时间只会越来越长</p>
<p><del>并不妨碍这题我没思路写</del>        道阻且长道阻且长</p>
<pre><code>class Solution &#123;
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();

    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);

        backTrack(nums, used);

        return result;
    &#125;

    private void backTrack(int[] nums, boolean[] used) &#123;
        if (path.size() == nums.length) &#123;
            result.add(new ArrayList&lt;&gt;(path));
            return;
        &#125;
        for (int i = 0; i &lt; nums.length; i++) &#123;
            //  true 上下层 false 同层，if线  同层使用过代表if和本线相同 跳
            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) &#123;
                continue;
            &#125;

            if (used[i] == false) &#123;
                used[i] = true;
                path.add(nums[i]);

                backTrack(nums, used);

                path.remove(path.size() - 1);
                used[i] = false;//回溯
            &#125;
        &#125;
    &#125;
&#125;   
</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-day28"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2023/04/11/day28/"
    >代码随想录算法训练营Day28|93 78 90</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2023/04/11/day28/" class="article-date">
  <time datetime="2023-04-11T08:56:44.000Z" itemprop="datePublished">2023-04-11</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="93-复原IP地址"><a href="#93-复原IP地址" class="headerlink" title="93 复原IP地址"></a>93 复原IP地址</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/restore-ip-addresses/">力扣题目链接</a></p>
<p>和上一题一样，不过检测回文变成了ip判断</p>
<pre><code>class Solution &#123;
    List&lt;String&gt; result = new ArrayList&lt;String&gt;();
    StringBuilder stringBuilder = new StringBuilder();

    public List&lt;String&gt; restoreIpAddresses(String s) &#123;
        restoreIpAddressesHandler(s, 0, 0);
        return result;
    &#125;


    public void restoreIpAddressesHandler(String s, int start, int number) &#123;

        if (start == s.length() &amp;&amp; number == 4) &#123;
            result.add(stringBuilder.toString());
            return;
        &#125;
        if (start == s.length() || number == 4) &#123;
            return;
        &#125;
                    //这一段的范围……
        for (int i = start; i &lt; s.length() &amp;&amp; i - start &lt; 3 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &gt;= 0
                &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255; i++) &#123;

            if (i + 1 - start &gt; 1 &amp;&amp; s.charAt(start) - &#39;0&#39; == 0) &#123;
                continue;
            &#125;
            stringBuilder.append(s.substring(start, i + 1));

            if (number &lt; 3) &#123;
                stringBuilder.append(&quot;.&quot;);
            &#125;
            number++;

            restoreIpAddressesHandler(s, i + 1, number);
            number--;
            stringBuilder.delete(start + number, i + number + 2);
        &#125;
    &#125; 
</code></pre>
<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78 子集"></a>78 子集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">力扣题目链接</a></p>
<p>收集树形结构中树的所有节点，说明白不就好了</p>
<pre><code>class Solution &#123;
    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();
    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();
    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;
        subsetsHelper(nums, 0);
        return result;
    &#125;

    private void subsetsHelper(int[] nums, int startIndex)&#123;
        result.add(new ArrayList&lt;&gt;(path));
        if (startIndex &gt;= nums.length)&#123;    // ?
            return;
        &#125;
        for (int i = startIndex; i &lt; nums.length; i++)&#123;
            path.add(nums[i]);
            subsetsHelper(nums, i + 1);
            path.removeLast();
        &#125;
    &#125;
&#125; 
</code></pre>
<h2 id="90-子集"><a href="#90-子集" class="headerlink" title="90 子集"></a>90 子集</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets-ii/">力扣题目链接</a></p>
<p>树层还是树枝？</p>
<pre><code>lass Solution &#123;

  List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();
  LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();

  public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup( int[] nums ) &#123;
    Arrays.sort( nums );
    subsetsWithDupHelper( nums, 0 );
    return res;
  &#125;


  private void subsetsWithDupHelper( int[] nums, int start ) &#123;
    res.add( new ArrayList&lt;&gt;( path ) );

    for ( int i = start; i &lt; nums.length; i++ ) &#123;

      if ( i &gt; start &amp;&amp; nums[i - 1] == nums[i] ) 
        continue;


      path.add( nums[i] );
      subsetsWithDupHelper( nums, i + 1 );
      path.removeLast();
    &#125;
  &#125;

&#125;  
</code></pre>
<p>回溯的知识轮廓是有了，但是我的实操……最近事太多了</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2023
        <i class="ri-heart-fill heart_icon"></i> safir
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="亦"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Code</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/aboutme">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="52"
        src="//music.163.com/outchain/player?type=2&id=535056564&auto=1&height=32"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>