<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代码随想录算法训练营Day3|链表p1 203、707、206</title>
    <url>/2023/03/17/day3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="链表理论基础"><a href="#链表理论基础" class="headerlink" title="链表理论基础"></a>链表理论基础</h2><p>学408数据结构的时候，链表应该是第2章来着，所以非常熟悉，不过毕竟是伪代码，所以现在来写……还是不太行。令人头疼的倒不是next指针，而是头指针、尾指针，带头指针的插入，不带头指针的插入。408选择题出链表一般都是插入删除后prev、next的指向，循环链表，几个月了题型有点忘。结构不难，就是指针比较烦罢了。</p>
<p>存储空间零散，不需要特别记。但是链表的结构体、基本操作的代码还是需要特意记的。</p>
<p>C/C++的定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(int x) : val(x),next(NULL)&#123;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>王道的单链表节点类型描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct LNode&#123;</span><br><span class="line">    Elemtype data;</span><br><span class="line">    struct LNode *next;</span><br><span class="line">&#125;LNode, *LinkList;</span><br></pre></td></tr></table></figure>

<p>初始化节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* head = new ListNode();</span><br></pre></td></tr></table></figure>

<p>删除、插入都是改变指针指向，再free。</p>
<p>链表与数组性能分析，查询、增减问题。</p>
<p>具体的基础指令代码什么的，我有现实笔记（还有王道书）总之基础理解不成问题。</p>
<p>毕竟我现在主要在看java。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    // 结点的值</span><br><span class="line">    int val;</span><br><span class="line"></span><br><span class="line">    // 下一个结点</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    // 节点的构造函数(无参)</span><br><span class="line">    public ListNode() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 节点的构造函数(有一个参数)</span><br><span class="line">    public ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 节点的构造函数(有两个参数)</span><br><span class="line">    public ListNode(int val, ListNode next) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h2><p>题目链接：<a href="https://leetcode.cn/problems/remove-linked-list-elements/">力扣</a></p>
<p>不知道有虚拟指针这种操作，受教了，的确比纠结头指针来的好，众生平等，众生平等，阿门。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeElements(ListNode head, int val) &#123;</span><br><span class="line">            if(head == null)&#123;    //先判空</span><br><span class="line">                return null;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ListNode extra = new ListNode (-1,head); //设置虚拟指针</span><br><span class="line">            ListNode pre = extra;</span><br><span class="line">            ListNode cur = head;</span><br><span class="line">            while(cur != null)&#123;        //经典筛选时间，删除就是next指针直接跳过指向指向下一个</span><br><span class="line">                if(cur.val==val)&#123;</span><br><span class="line">                    pre.next=cur.next;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    pre=cur;</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125; </span><br><span class="line">            return extra.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有什么特别要说的，因为思路的确很简单，就是如何写代码。</p>
<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707 设计链表"></a>707 设计链表</h2><p><a href="https://leetcode.cn/problems/design-linked-list/">力扣题目链接</a></p>
<p>惊到我了，就是让你写这些基础功能如何实现的。408的数据结构也的确是有，不过不考，而且重点是头指针有无情况下的增删操作（于是好好看了一遍之后忘了……），不过这是必要的写代码，总是要写的。</p>
<p>get（index）</p>
<p>addAtHead(val)</p>
<p>addAtTail(val)</p>
<p>addAtIndex(index,val)</p>
<p>deleteAtIndex(index)</p>
<p>以上都是操作链表的基础操作，但是基础代码也是要写出来才能调用的啊</p>
<p>408专门讲了链表的指针在删除、添加方面是怎么指向的，所以我只是不会写代码，但是是纸上谈兵的纯新手（望天）每日一嚎实操能力。</p>
<p>第2、3个可以直接用最后一个变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode&#123;</span><br><span class="line">    int val;      //链表的基础框架</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode()&#123;  &#125;</span><br><span class="line">    ListNode(int val)&#123;</span><br><span class="line">        this.val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyLinkedList &#123;</span><br><span class="line">                            //链表的基础操作类先定义一下size head</span><br><span class="line">    int size;</span><br><span class="line">    ListNode head;</span><br><span class="line"></span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        size=0;                   //初始化</span><br><span class="line">        head=new ListNode(0);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int index) &#123;       //get，用了虚拟指针</span><br><span class="line">           if(index&gt;=size || index&lt;0)&#123;</span><br><span class="line">               return -1;</span><br><span class="line">           &#125;</span><br><span class="line">           ListNode extra =head;</span><br><span class="line">           for(int i=0;i&lt;=index;i++)&#123;</span><br><span class="line">               extra=extra.next;</span><br><span class="line">           &#125;</span><br><span class="line">           return extra.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addAtHead(int val) &#123;   //2、3套5</span><br><span class="line">            addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addAtTail(int val) &#123;</span><br><span class="line">             addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addAtIndex(int index, int val) &#123;  //插入元素，依然用虚拟指针</span><br><span class="line">            if(index &gt; size)&#123;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            if(index&lt;0)&#123;</span><br><span class="line">                index=0;</span><br><span class="line">            &#125;</span><br><span class="line">            size++;</span><br><span class="line">            ListNode pred=head;</span><br><span class="line">            for(int i=0;i&lt;index;i++)&#123;</span><br><span class="line">                pred=pred.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode ad=new ListNode(val);</span><br><span class="line">            ad.next=pred.next;</span><br><span class="line">            pred.next=ad;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">            if(index&lt;0 || index&gt;=size)&#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            size--;</span><br><span class="line">            if(index==0)&#123;</span><br><span class="line">                head=head.next;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode pred = head;</span><br><span class="line">            for(int i=0;i&lt;index;i++)&#123;</span><br><span class="line">                pred=pred.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pred.next=pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>双链表（还没尝试）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ListNode&#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next,prev;</span><br><span class="line">    ListNode() &#123;&#125;;</span><br><span class="line">    ListNode(int val)&#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyLinkedList &#123;  </span><br><span class="line"></span><br><span class="line">    //记录链表中元素的数量</span><br><span class="line">    int size;</span><br><span class="line">    //记录链表的虚拟头结点和尾结点</span><br><span class="line">    ListNode head,tail;</span><br><span class="line">    </span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        //初始化操作</span><br><span class="line">        this.size = 0;</span><br><span class="line">        this.head = new ListNode(0);</span><br><span class="line">        this.tail = new ListNode(0);</span><br><span class="line">        //这一步非常关键，否则在加入头结点的操作中会出现null.next的错误！！！</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.prev=head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">        //判断index是否有效</span><br><span class="line">        if(index&lt;0 || index&gt;=size)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = this.head;</span><br><span class="line">        //判断是哪一边遍历时间更短</span><br><span class="line">        if(index &gt;= size / 2)&#123;</span><br><span class="line">            //tail开始</span><br><span class="line">            cur = tail;</span><br><span class="line">            for(int i=0; i&lt; size-index; i++)&#123;</span><br><span class="line">                cur = cur.prev;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            for(int i=0; i&lt;= index; i++)&#123;</span><br><span class="line">                cur = cur.next; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addAtHead(int val) &#123;</span><br><span class="line">        //等价于在第0个元素前添加</span><br><span class="line">        addAtIndex(0,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addAtTail(int val) &#123;</span><br><span class="line">        //等价于在最后一个元素(null)前添加</span><br><span class="line">        addAtIndex(size,val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addAtIndex(int index, int val) &#123;</span><br><span class="line">        //index大于链表长度</span><br><span class="line">        if(index&gt;size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //index小于0</span><br><span class="line">        if(index&lt;0)&#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">        //找到前驱</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">        for(int i=0; i&lt;index; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        //新建结点</span><br><span class="line">        ListNode newNode = new ListNode(val);</span><br><span class="line">        newNode.next = pre.next;</span><br><span class="line">        pre.next.prev = newNode;</span><br><span class="line">        newNode.prev = pre;</span><br><span class="line">        pre.next = newNode;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">        //判断索引是否有效</span><br><span class="line">        if(index&lt;0 || index&gt;=size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //删除操作</span><br><span class="line">        size--;</span><br><span class="line">        ListNode pre = this.head;</span><br><span class="line">        for(int i=0; i&lt;index; i++)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next.next.prev = pre;</span><br><span class="line">        pre.next = pre.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>双链表应该比单链表有效率的多。</p>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣题目链接</a></p>
<p>开始的确觉得是要新开链表然后一个个转过去，先遍历到最后一个，知道长度再设置新链表，嗯……双链表还好，单链表的查找更麻烦了。直接把链表的指针反转怎么就没想到呢。</p>
<p>如果直接把指针反转的话，应该考虑指针改变的顺序问题，不然链表就丢失了，还是需要捋捋的。</p>
<p>A设为头指针，ex是存前一个地址的指针。</p>
<p>A.next用temp表示，再把next指向ex；A本身地址给ex，temp为新的A</p>
<p>还是挺绕的，建议画图。在电脑上画图有点麻烦</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">         ListNode prev = null;</span><br><span class="line">         ListNode cur = head;</span><br><span class="line">         ListNode temp = null;</span><br><span class="line">         while(cur != null)&#123;</span><br><span class="line">             temp = cur.next;     //注意这四段代码中2个指针的改变</span><br><span class="line">             cur.next = prev;</span><br><span class="line">             prev = cur;</span><br><span class="line">             cur = temp;</span><br><span class="line">         &#125;</span><br><span class="line">         return prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prev、cur、head、hail、prior、past  经典设置名字</p>
]]></content>
  </entry>
  <entry>
    <title>代码随想录算法训练营Day2|数组977、209、59</title>
    <url>/2023/03/16/d2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="977-有序数组的平方"><a href="#977-有序数组的平方" class="headerlink" title="977 有序数组的平方"></a>977 有序数组的平方</h2><style></style>

<p>题目链接：<a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣</a></p>
<p>没有看见题目建议是双指针，也没看见进阶要求时间复杂度为O（n），是我的错，当即写了暴力解，然后时间超时（望天）明明我昨天才感慨完双指针……</p>
<p>垃圾暴力解（继续望天）因为直接超时所以我连自己的代码质量都不知道（继续继续望天</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">            int s=nums.length;</span><br><span class="line">            int[] sq = new int[nums.length];</span><br><span class="line">            for(int i=0;i&lt;=s-1;i++)&#123;</span><br><span class="line">                sq[i]=nums[i]*nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            for(int j=1;j&lt;=s-1;j++)&#123;</span><br><span class="line">                for(int k=1;k&lt;=s;s++)&#123;</span><br><span class="line">                    if(sq[k]&lt;sq[k-1])&#123;</span><br><span class="line">                        int temp=sq[k];</span><br><span class="line">                        sq[k]=sq[k-1];</span><br><span class="line">                        sq[k-1]=temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return sq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码随想录的暴力解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;</span><br><span class="line">        for (int i = 0; i &lt; A.size(); i++) &#123;</span><br><span class="line">            A[i] *= A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(A.begin(), A.end()); // 快速排序</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>核心代码模式可以直接快排吗？？？</p>
<p>自己写的暴力解显现出了另一个问题：数组的溢出，鉴于自己真的太久没看基础了，这种错误当然是会犯的啊哈哈哈，不行，我真的得要重新过一遍了。</p>
<p><u>java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5</u></p>
<p>java的数组报错，下标越界，length、int[0]直接套就会出现这种事，混乱</p>
<p>双指针思路看懂了，毕竟是有负数的数组，平方后绝对值说不定是最大的，那么就从排序的最大值开始排好了，最大值只会从两边出现，所以就用双指针一个头一个尾开始比较。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] sortedSquares(int[] nums) &#123;</span><br><span class="line">         int last =nums.length-1;</span><br><span class="line">         int first = 0;</span><br><span class="line">         int[] sq = new int[nums.length];</span><br><span class="line">         int index = sq.length-1;</span><br><span class="line">         while(first&lt;=last)&#123;</span><br><span class="line">             if(nums[first]*nums[first]&gt;nums[last]*nums[last])&#123;</span><br><span class="line">                 sq[index--]=nums[first]*nums[first];</span><br><span class="line">                 first++;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                 sq[index--]=nums[last]*nums[last];</span><br><span class="line">                 last--;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return sq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(思路不是问题，问题是我不会写代码，啊)</p>
<h2 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209 长度最小的子数组"></a>209 长度最小的子数组</h2><style></style>

<p>题目链接：<a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣</a></p>
<p>初始反而没想出来暴力解，反而在想边框，先长度为2，再长度为3滑动，不过这也是两层for循环，而且理解起来也麻烦，不提不提，比暴力解还要麻烦。还是双指针，两个指针框起来的就是数组。实操，思路还是要实操，所以怎么写</p>
<p>A先不动，滑B，大于数值，滑A，一直到相等，时间复杂度O（n）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSubArrayLen(int target, int[] nums) &#123;</span><br><span class="line">       int A = 0;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       int correct = Integer.MAX_VALUE;</span><br><span class="line">       for(int B = 0;B&lt;nums.length;B++)&#123;</span><br><span class="line">           sum+=nums[B];</span><br><span class="line">           while(sum&gt;=target)&#123;  //本来觉得if可以，然后示例挂了。后来想了一下发现，减一次也不一定就能重回目标值，毕竟数字又不是均等的</span><br><span class="line">               correct = Math.min(correct,B-A+1);</span><br><span class="line">               sum-=nums[A];</span><br><span class="line">               A++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return correct ==Integer.MAX_VALUE ? 0 : correct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-螺旋矩阵II"><a href="#59-螺旋矩阵II" class="headerlink" title="59 螺旋矩阵II"></a>59 螺旋矩阵II</h2><style></style>

<p>题目链接：<a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣</a></p>
<p>乍一看没什么，但是再一想就感觉麻烦度蹭蹭的上涨，这可不是具体给个数，而是固定化的步骤，用数组表示，划分区间，但是我对数组的掌控度很不够。从行、从列调控二维数组，内圈的尺寸也需要代码规定，让我想起了解函数设一堆x的代数式，不过还是简洁不起来。</p>
<p>比之前的难，去视频看了一眼最后几行是什么意思，是最后一圈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">       int loop = 0;</span><br><span class="line">       int [][] res = new int[n][n];</span><br><span class="line">       int start = 0;</span><br><span class="line">       int min = 1;</span><br><span class="line">       int i,j;</span><br><span class="line"></span><br><span class="line">       while(loop++ &lt; n/2)&#123;     //上</span><br><span class="line">           for(j=start;j&lt;n-loop;j++)&#123;</span><br><span class="line">               res[start][j]=min++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           for(i=start;i&lt;n-loop;i++)&#123;    //右</span><br><span class="line">               res[i][j]=min++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           for(;j&gt;=loop;j--)&#123;    //下</span><br><span class="line">               res[i][j]=min++;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           for(;i&gt;=loop;i--)&#123;      //左</span><br><span class="line">               res[i][j]=min++;</span><br><span class="line"></span><br><span class="line">           start++;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if(n%2==1)&#123;</span><br><span class="line">           res[start][start]=min;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际表达出来仅仅是while加4个for,简洁明了，这就是代码的魅力所在啊</p>
<p>loop、start、n，三者控制 i、j的位置，然后就min一直加下去。</p>
<p>n-loop,让我想起经典勾股定理证明图形，4个长方形加中间正方形等于大正方形。</p>
<p>我逐渐明白了一切.jpg</p>
]]></content>
  </entry>
  <entry>
    <title>代码随想录算法训练营Day1|数组、二分、移除</title>
    <url>/2023/03/15/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E7%AE%97%E6%B3%95day1%E6%95%B0%E7%BB%84%E4%BA%8C%E5%88%86%E7%A7%BB%E9%99%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="代码随想录算法训练营Day1-数组、二分、移除"><a href="#代码随想录算法训练营Day1-数组、二分、移除" class="headerlink" title="代码随想录算法训练营Day1|数组、二分、移除"></a>代码随想录算法训练营Day1|数组、二分、移除</h1><h2 id="数组理论（非常基础的数据结构）"><a href="#数组理论（非常基础的数据结构）" class="headerlink" title="数组理论（非常基础的数据结构）"></a>数组理论（非常基础的数据结构）</h2><p>当初学408的时候，甚至追到大一的c语言课程，数组都是非常重要的知识点，理解起来并没有那么困难，不过直到如今指针依然是让我脑壳疼的存在，也不是地址的连续性与计算。非要描述的话，就是定义、描述？</p>
<p>数组就像是队伍的行列，也可以打个比方为生物课本里一排排的植物细胞显微镜下的状态……一个细胞占一小段连续的内存。只要知道基准点和下标，地址非常好求，按图索骥。</p>
<p>对，二维数组指针让人头疼，每行的首指针貌似（记忆过于久远了），不过这针对的是c语言，个人目前打算研究Java。而Java没有指针真是个好消息。而Java的二维数组嘛，就像是不同的书的名字，每个名字后面跟着目录，从一开始就互不关联。</p>
<p>说回数组本身，408简直不能忽视。数据结构就不用多说了，与其相似的还有栈、链表，数组可以用链表表示，不过过于麻烦。图，广度搜索、深度搜索等等都是以数组为基础（今年代码题竟然不考算法，考图，我……）。排序、搜索不用多说。计网pass，计网都是各种协议。操作系统的文件系统与数组的内存可以说是差不离，都是以起始点，每个文件的大小来进行计算，不同的大概只有文件系统需要考虑的位数指代多少内存。计组，与操作系统同理，深化到了程序指令的内存地址。荣耀归于计算机组成原理——  只要会计组，操作系统简直不在话下（问题是我寄了啊啊啊……）  如果数组不熟练，我会翻出王道书和C primer plus再看一遍，真的，关于数组过长时间没看过了。</p>
<h2 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704.二分查找"></a>704.二分查找</h2><style></style>

<p>题目链接：<a href="https://leetcode.cn/problems/binary-search/">力扣</a></p>
<p>408数据结构接触过（但是你没实操啊没实操），变形我记得可以用双指针法，历年真题里面不少双指针，王道甚至某一年的真题给的三指针震撼我一整年。虽然，咳，这题暂时还没那么高大上……</p>
<p>简而言之就是明确界限，左边界限、右边界限、由此确定的中间的比较值。根据比较值与目标值的比较大小关系再把中间值定为新的左or右界限，取新中间值，如此往复直到找到。</p>
<p>虽然思路很明确，但是对我来说最大的问题是——不知道如何下手。</p>
<p>定义谁？for循环肯定是双层，判断条件怎么写，就是一头雾水。</p>
<p>所以说啊（痛心疾首），实践出真知，你纸上谈兵不还是什么都没干吗？这是我用一年得出的惨痛教训T_T</p>
<p>先定义左右，然后是middle，不过首先是while循环这个我倒是没想到的，比较之后如何确定新边界是个关键点。由此引申出区间的定义，要不要最右边的那个数。两种定义，写法会有微妙的不同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">    public int search(int[] nums, int target) &#123;</span><br><span class="line">         int left = 0;</span><br><span class="line">         int right = nums.length-1;</span><br><span class="line">         while(left &lt;= right)&#123;</span><br><span class="line">             int middle = left +((right - left)/2);// &gt;&gt;1 位运算呐</span><br><span class="line">             if(nums[middle] &gt; target)&#123;</span><br><span class="line">                 right = middle - 1;</span><br><span class="line">             &#125;else if (nums[middle] &lt; target)&#123;</span><br><span class="line">                 left = middle + 1;</span><br><span class="line">             &#125;else &#123;</span><br><span class="line">                 return middle;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（全比较版本）</p>
<p>抛去右边的话（因为递增顺序，右边一般来说不用），while循环直接&lt;,length不减，左区间重定位middle，右区间保持middle+1。</p>
<p>size（）函数不能用，面对编译一脸懵逼，上次编译失败是‘ ‘这对符号错误，而且又和指针有关，最后也没解决…… Java，果然还是用length</p>
<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27.移除元素"></a>27.移除元素</h2><style></style>

<p>题目链接：<a href="https://leetcode.cn/problems/remove-element/">力扣</a></p>
<p>简单地删除元素就没什么好说的，直接遍历for走起，问题是，这是数组，只能覆盖，突然就觉得链表不那么面目可憎了（</p>
<p>双指针真是太好用了，暴力解速度没问题但是内存稍微高一点。每日一轮自己的实操。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">         int num=nums.length;</span><br><span class="line">         for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">              if(nums[i]==val)&#123;</span><br><span class="line">                for(int j=i+1;j&lt;num;j++)&#123;</span><br><span class="line">                    nums[j-1]=nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">            i--;</span><br><span class="line">            num--;</span><br><span class="line">         &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      return num;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是快慢指针，简而言之就是把快指针遍历过的元素用慢指针在原数组上原地誊写。遇到要删除的元素，快指针跳过，慢指针无情把这格覆盖掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">         int slowIndex = 0;</span><br><span class="line">        for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) &#123;</span><br><span class="line">            if (nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex] = nums[fastIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slowIndex;</span><br><span class="line">    &#125;   </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此处用的是代码随想录上的示例代码。</p>
<h2 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h2><p>二分查找除了704，还有35 34两题，有空要看看。</p>
<p>marktext真好用啊，typora付费有点不舍，可惜如果我要买点什么我会先打算买marginnote 3</p>
<p>痛苦做毕设，等毕设做完就能愉快搞代码了</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/13/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
